1/27
(43,122,1)
proposal to unify native/green tasks:
	(stacks/thread, tasks/stacks)
	(1, 1) => current Rust native tasks
	(1, N) => Python greenlets
	(N, 1) => current Rust green tasks
	(N, M) => proposal in my original mail
tenuous since there is code written with different assumptions
(43,125,5)
Asynchronous replies like Akka Futures: http://doc.akka.io/docs/akka/snapshot/scala/futures.html)
Turning asynchronous requests into synchronous operation (Akka doesn't have this)
ZMQ (inter-task communication): http://zeromq.org/
(43,131,4)
Some issues with rustpkg, may be deprecated soon (why?)

1/25
Actor model mentioned as useful, something Erlang/OTP-like (43, 117)
Performance concerns about actors (43, 118, 3)
Two different kinds of tasks:
	Native tasks - analogous to OS threads
	Green tasks - analogous to user threads
Proposal to swtich green stacks from large stacks to memcpyed stacks (43, 118, 4)

1/24
Channel debate is nearly resolved.
Focus of rust is on single consumer message passing (Vol 43, Issue 114)
	issue taken with no shared memory, points to Arc/MutexArc
	i.e. concurrent hash table split into shards
	Wants concurrency to be based on multiple-consumer/producer queue
	response (Vol 43, Issue 115)
		it's the easiest conceptually, concurrency pkg in future
		difficulty with proposed queue is select on multiple consumers

1/21
Bounded/unbounded channels seem to be a major issue.
	stronger arguments for bounded
libgreen (user threads)/libnative (OS threads) split from libstd
	don't think this influences where the actor library goes
Avoid foo/foo-opt issues
Macros can have multiple items, but only one statement
Many different kinds of channels (to be implemented)
	Chan trait, unbounded:
		throws errors for potential overflow
		multi-producer
	SharedChan, from Chan (could just be Chan): multi-consumer
	UniqueChan, from Chan: single-consumer
	SyncChan, bounded:
		blocking send
		returning try_send: success/full/closed return
		multi-producer, single-consumer
Code reviewing: https://github.com/mozilla/rust/wiki/Note-code-review
gdb to get error backtraces, break on rust_fail
Rust Continuous Integration: http://www.rust-ci.org/help/
pointers are implicitly copyable unless destructor is created
	i.e. original pointer is invalid when copied into another struct


